package interceptor

import (
	"context"
	"fmt"
	"reflect"

	grpcauth "github.com/grpc-ecosystem/go-grpc-middleware/auth"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type TokenInfo struct {
	ID    string
	Roles []string
}

// contextKey custom key type for context.WithValue
type contextKey string

const (
	// tokenInfoKey key for storing TokenInfo in context
	tokenInfoKey contextKey = "tokenInfo"
)

// excluded methods that need to skip authentication
var excludedAuthMethods = map[string]bool{
	"/api.agent.v1.Agent/Heartbeat":  true,
	"/api.job.v1.Job/Ping":           true,
	"/api.stream.v1.Stream/Ping":     true,
	"/api.pipeline.v1.Pipeline/Ping": true,
}

// AuthUnaryInterceptor unary server interceptor (can skip heartbeat interface)
func AuthUnaryInterceptor() grpc.UnaryServerInterceptor {
	return func(
		ctx context.Context,
		req any,
		info *grpc.UnaryServerInfo,
		handler grpc.UnaryHandler,
	) (any, error) {
		// check if need to skip authentication
		if excludedAuthMethods[info.FullMethod] {
			return handler(ctx, req)
		}

		// execute authentication with request context
		token, err := grpcauth.AuthFromMD(ctx, "bearer")
		if err != nil {
			return nil, err
		}
		tokenInfo, err := parseToken(token, req)
		if err != nil {
			return nil, status.Errorf(codes.Unauthenticated, " %v", err)
		}
		// use custom type as key, avoid conflict with other package's context key
		newCtx := context.WithValue(ctx, tokenInfoKey, tokenInfo)
		return handler(newCtx, req)
	}
}

// AuthStreamInterceptor stream server interceptor (can skip heartbeat interface)
func AuthStreamInterceptor() grpc.StreamServerInterceptor {
	return func(
		srv any,
		ss grpc.ServerStream,
		info *grpc.StreamServerInfo,
		handler grpc.StreamHandler,
	) error {
		// check if need to skip authentication
		if excludedAuthMethods[info.FullMethod] {
			return handler(srv, ss)
		}

		// execute authentication with stream context
		token, err := grpcauth.AuthFromMD(ss.Context(), "bearer")
		if err != nil {
			return status.Errorf(codes.Unauthenticated, "failed to get token: %v", err)
		}
		tokenInfo, err := parseToken(token, nil)
		if err != nil {
			return status.Errorf(codes.Unauthenticated, " %v", err)
		}
		newCtx := context.WithValue(ss.Context(), tokenInfoKey, tokenInfo)

		// create new ServerStream wrapper
		wrapped := &wrappedServerStream{
			ServerStream: ss,
			ctx:          newCtx,
		}

		return handler(srv, wrapped)
	}
}

// wrappedServerStream wrap ServerStream to replace context
type wrappedServerStream struct {
	grpc.ServerStream
	ctx context.Context
}

func (w *wrappedServerStream) Context() context.Context {
	return w.ctx
}

func AuthInterceptor(ctx context.Context) (context.Context, error) {
	token, err := grpcauth.AuthFromMD(ctx, "bearer")
	if err != nil {
		return nil, err
	}
	tokenInfo, err := parseToken(token, nil)
	if err != nil {
		return nil, status.Errorf(codes.Unauthenticated, " %v", err)
	}
	// use custom type as key, avoid conflict with other package's context key
	newCtx := context.WithValue(ctx, tokenInfoKey, tokenInfo)
	return newCtx, nil
}

// GetTokenInfofromContext get TokenInfo from context
func GetTokenInfofromContext(ctx context.Context) (*TokenInfo, bool) {
	value := ctx.Value(tokenInfoKey)
	if value == nil {
		return nil, false
	}
	tokenInfo, ok := value.(TokenInfo)
	if !ok {
		return nil, false
	}
	return &tokenInfo, true
}

// TokenVerifier interface for token verification
// This allows different implementations (config-based, database-based, etc.)
type TokenVerifier interface {
	// VerifyAgentToken verifies a token generated by generateAgentToken and returns agent ID if valid
	// agentIDHint: optional agent ID from request, if provided, verify this agent first (optimization)
	// Returns empty string if token is invalid or agent not found
	VerifyAgentToken(token string, agentIDHint string) (string, error)
}

// defaultTokenVerifier default token verifier using hardcoded token
type defaultTokenVerifier struct{}

func (v *defaultTokenVerifier) VerifyAgentToken(token string, agentIDHint string) (string, error) {
	// Default implementation: return empty to indicate token verification not supported
	return "", fmt.Errorf("agent token verification not implemented")
}

var tokenVerifier TokenVerifier = &defaultTokenVerifier{}

// SetTokenVerifier sets the token verifier (can be called during initialization)
func SetTokenVerifier(verifier TokenVerifier) {
	tokenVerifier = verifier
}

// parse token and validate
// req can be nil, but if provided and contains agent_id, it will be used for optimization
func parseToken(token string, req any) (TokenInfo, error) {
	var tokenInfo TokenInfo

	// Support legacy hardcoded token
	if token == "grpc.auth.token" {
		tokenInfo.ID = "1"
		tokenInfo.Roles = []string{"admin"}
		return tokenInfo, nil
	}

	// Try to extract agent_id from request if available (optimization)
	var agentIDFromReq string
	if req != nil {
		agentIDFromReq = extractAgentIDFromRequest(req)
	}

	// Verify as agent token (generated by generateAgentToken using HMAC-SHA256)
	agentID, err := verifyAgentToken(token, agentIDFromReq)
	if err == nil && agentID != "" {
		tokenInfo.ID = agentID
		tokenInfo.Roles = []string{"agent"} // Default role for agents
		return tokenInfo, nil
	}

	return tokenInfo, fmt.Errorf("invalid token: %v", err)
}

// extractAgentIDFromRequest extracts agent_id from request using reflection
func extractAgentIDFromRequest(req any) string {
	if req == nil {
		return ""
	}

	// Use reflection to extract agent_id field
	rv := reflect.ValueOf(req)
	if rv.Kind() == reflect.Ptr {
		rv = rv.Elem()
	}

	if rv.Kind() != reflect.Struct {
		return ""
	}

	// Try common field names: AgentId, AgentID, agent_id
	fieldNames := []string{"AgentId", "AgentID", "agent_id"}
	for _, fieldName := range fieldNames {
		field := rv.FieldByName(fieldName)
		if field.IsValid() && field.Kind() == reflect.String {
			agentID := field.String()
			if agentID != "" {
				return agentID
			}
		}
	}

	// Try GetAgentId() method if exists
	method := rv.MethodByName("GetAgentId")
	if !method.IsValid() {
		method = rv.MethodByName("GetAgentID")
	}
	if method.IsValid() && method.Type().NumIn() == 0 && method.Type().NumOut() == 1 {
		results := method.Call(nil)
		if len(results) > 0 {
			if agentID, ok := results[0].Interface().(string); ok && agentID != "" {
				return agentID
			}
		}
	}

	return ""
}

// verifyAgentToken verifies a token generated by generateAgentToken
// The token is generated using HMAC-SHA256 with secret key and salt from database
// Reference: internal/engine/service/service_agent.go generateAgentToken
// agentIDHint: optional agent ID from request, if provided, verify this agent first
func verifyAgentToken(token string, agentIDHint string) (string, error) {
	// Use TokenVerifier to verify the token
	agentID, err := tokenVerifier.VerifyAgentToken(token, agentIDHint)
	if err != nil {
		return "", fmt.Errorf("failed to verify agent token: %w", err)
	}
	if agentID == "" {
		return "", fmt.Errorf("agent token verification failed: agent not found")
	}
	return agentID, nil
}
