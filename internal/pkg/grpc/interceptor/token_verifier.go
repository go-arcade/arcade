// Copyright 2025 Arcade Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package interceptor

import (
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"strings"
	"time"

	"github.com/bytedance/sonic"
	"github.com/go-arcade/arcade/internal/engine/repo"
	"github.com/go-arcade/arcade/internal/engine/service"
	"github.com/go-arcade/arcade/pkg/cache"
	"github.com/go-arcade/arcade/pkg/log"
	"github.com/redis/go-redis/v9"
)

// agentSecretConfig represents the structure of agent secret key configuration
type agentSecretConfig struct {
	Salt      string `json:"salt"`
	SecretKey string `json:"secret_key"`
}

// agentTokenVerifier implements TokenVerifier interface for agent token verification
type agentTokenVerifier struct {
	agentService           *service.AgentService
	agentRepo              repo.IAgentRepository
	generalSettingsService *service.GeneralSettingsService
	cache                  cache.ICache
}

const (
	// redisCacheKey is the Redis key for agent secret config cache
	redisCacheKey = "agent:agent_secret_key"
	// redisCacheTTL is the TTL for agent secret config cache (24 hours)
	redisCacheTTL = 24 * time.Hour
)

// NewAgentTokenVerifier creates a new agent token verifier
func NewAgentTokenVerifier(agentService *service.AgentService, agentRepo repo.IAgentRepository, generalSettingsService *service.GeneralSettingsService, cache cache.ICache) TokenVerifier {
	return &agentTokenVerifier{
		agentService:           agentService,
		agentRepo:              agentRepo,
		generalSettingsService: generalSettingsService,
		cache:                  cache,
	}
}

// getSecretConfig gets agent secret key configuration with caching
// Priority: Redis cache -> Memory cache -> Database
func (v *agentTokenVerifier) getSecretConfig() (*agentSecretConfig, error) {
	ctx := context.Background()

	if v.cache != nil {
		cached, err := v.cache.Get(ctx, redisCacheKey).Result()
		if err == nil && cached != "" {
			var cfg agentSecretConfig
			if sonic.Unmarshal([]byte(cached), &cfg) == nil && cfg.SecretKey != "" {
				return &cfg, nil
			}
		}

		if err != nil && !isCacheMiss(err) {
			log.Warnw("cache get failed, fallback to DB", "error", err)
		}
	}

	settings, err := v.generalSettingsService.GetGeneralSettingsByName("system", "agent_secret_key")
	if err != nil {
		log.Errorw("failed to get agent secret key configuration", "error", err)
		return nil, err
	}

	var config agentSecretConfig
	if err := sonic.Unmarshal(settings.Data, &config); err != nil {
		log.Errorw("failed to unmarshal agent secret key config", "error", err)
		return nil, err
	}

	// Validate
	if config.SecretKey == "" || config.Salt == "" {
		return nil, fmt.Errorf("invalid secret config from DB")
	}

	if v.cache != nil {
		bytes, _ := sonic.Marshal(&config)
		if setErr := v.cache.Set(ctx, redisCacheKey, bytes, redisCacheTTL).Err(); setErr != nil {
			log.Warnw("failed to cache agent secret config", "error", setErr)
		}
	}

	return &config, nil
}

func isCacheMiss(err error) bool {
	return err == redis.Nil || strings.Contains(err.Error(), "not found")
}

// generateToken generates a token for the given agentId using cached secret config
// Format: agentId:base64(signature)
func (v *agentTokenVerifier) generateToken(agentId string) (string, error) {
	config, err := v.getSecretConfig()
	if err != nil {
		return "", err
	}

	// Generate token using HMAC-SHA256
	h := hmac.New(sha256.New, []byte(config.SecretKey))
	h.Write([]byte(agentId))
	h.Write([]byte(config.Salt))
	signature := h.Sum(nil)

	signatureStr := base64.URLEncoding.EncodeToString(signature)
	token := fmt.Sprintf("%s:%s", agentId, signatureStr)
	return token, nil
}

// parseToken extracts agentId and signature from token
// Token format: agentId:base64(signature)
func (v *agentTokenVerifier) parseToken(token string) (agentId string, signature string, err error) {
	parts := strings.SplitN(token, ":", 2)
	if len(parts) != 2 {
		return "", "", fmt.Errorf("invalid token format: expected agentId:signature")
	}
	return parts[0], parts[1], nil
}

// VerifyAgentToken verifies a token generated by generateAgentToken
// Supports two token formats:
//  1. New format: agentId:base64(signature) - preferred, O(1) verification
//  2. Legacy format: base64(signature) - backward compatibility, requires agentIDHint or list all agents
func (v *agentTokenVerifier) VerifyAgentToken(token string, agentIDHint string) (string, error) {
	if token == "" {
		return "", fmt.Errorf("token is empty")
	}

	// Check if token is in new format (contains ':')
	if strings.Contains(token, ":") {
		// New format: agentId:signature
		agentId, _, err := v.parseToken(token)
		if err != nil {
			return "", fmt.Errorf("failed to parse token: %w", err)
		}

		if agentId == "" {
			return "", fmt.Errorf("agentId is empty in token")
		}

		// Verify agent exists
		_, err = v.agentRepo.GetAgentByAgentId(agentId)
		if err != nil {
			log.Debugw("agent not found", "agentId", agentId, "error", err)
			return "", fmt.Errorf("agent not found: %s", agentId)
		}

		// Regenerate expected token for this agentId and compare
		expectedToken, err := v.generateToken(agentId)
		if err != nil {
			return "", fmt.Errorf("failed to generate expected token: %w", err)
		}

		// Compare tokens
		if token != expectedToken {
			return "", fmt.Errorf("invalid token signature")
		}

		return agentId, nil
	}

	// Legacy format: only signature (base64 encoded), need to find agent by verifying against all agents
	// Optimization: if agentIDHint is provided, verify that agent first
	if agentIDHint != "" {
		expectedToken, err := v.generateToken(agentIDHint)
		if err == nil {
			// Extract signature from expected token (new format) for comparison
			_, expectedSignature, _ := v.parseToken(expectedToken)
			if token == expectedSignature {
				// Verify agent exists
				_, err := v.agentRepo.GetAgentByAgentId(agentIDHint)
				if err == nil {
					return agentIDHint, nil
				}
			}
		}
	}

	// Fallback: list all agents and verify token (legacy format)
	agents, _, err := v.agentRepo.ListAgent(1, 1000)
	if err != nil {
		log.Errorw("failed to list agents for token verification", "error", err)
		return "", fmt.Errorf("failed to list agents: %w", err)
	}

	// Try to find matching agent by verifying token signature
	for _, agent := range agents {
		// Skip if we already checked this agent
		if agentIDHint != "" && agent.AgentId == agentIDHint {
			continue
		}

		expectedToken, err := v.generateToken(agent.AgentId)
		if err != nil {
			log.Debugw("failed to generate token for agent", "agentId", agent.AgentId, "error", err)
			continue
		}

		// Extract signature from expected token (new format) for comparison
		_, expectedSignature, _ := v.parseToken(expectedToken)
		if token == expectedSignature {
			return agent.AgentId, nil
		}
	}

	return "", fmt.Errorf("no matching agent found for token")
}
