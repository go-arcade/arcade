name: Deploy to Amazon ECS
run-name: ${{ github.actor }} is testing out GitHub Actions üöÄ
on:
  push:
    branches:
      - develop # ÁõëÂê¨ `develop` ÂàÜÊîØ‰∏äÁöÑ push ‰∫ã‰ª∂
  pull_request:
    branches:
      - develop # ÁõëÂê¨ PR ÂêàÂπ∂Âà∞ `develop` ÂàÜÊîØÁöÑ‰∫ã‰ª∂
env:
  AWS_REGION: ap-southeast-1
  # È°πÁõÆÂêç
  ECR_REPOSITORY: arcade
  # deploy ÂâØÊú¨Êï∞
  REPLICAS: 1
  # deploy Â∫îÁî®Âêç
  SERVICE_NAME: arcade
  # ÂÅ•Â∫∑Ê£ÄÊü•Êó∂Èó¥
  HEALTH_TIME: 45
  # ÂÜÖÂ≠òÈôêÂà∂
  MEMORY_LIMITS: 2Gi
  # ÂÜÖÂ≠òËØ∑Ê±Ç
  MEMORY_REQUESTS: 500Mi
  # CPU ÈôêÂà∂
  CPU_LIMITS: 4
  # CPU ËØ∑Ê±Ç
  CPU_REQUESTS: 500m
  # ÊúçÂä°Á´ØÂè£
  PROJECT_PORT: 8080
  CONTAINER_NAME: arcade
  # È°πÁõÆÁ±ªÂûã
  PROJECT_TYPE: node
  # ÈïúÂÉè‰ªìÂ∫ìÂêç + Êñ∞Â¢û
  IMAGE_REPO_NAME: ghcr.io/go-arcade
  # NAMESPACE
  APP_NAMESPACE: arcade
  # build env
  APP_BUILD_ENV: prod
  # End Êñ∞Â¢û

jobs:
  Build-Code-Actions:
    runs-on: ubuntu-latest
    outputs:
      build_time: ${{ steps.build-image.outputs.build_time }}
    steps:
      - uses: actions/checkout@v4
      - name: Log in to GitHub Container Registry
        permissions:
          contents: read
          packages: write
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Build and push streampark
        id: build-image
        run: |
          BUILD_TIME=$(date +'%Y%m%d')
          IMAGE_TAG=${IMAGE_REPO_NAME}/${SERVICE_NAME}:$(git rev-parse --short HEAD | cut -c1-7)_$BUILD_TIME
          docker build -t ${IMAGE_TAG} .
          docker push $IMAGE_TAG
          echo "build_time=$BUILD_TIME" >> $GITHUB_OUTPUT
          echo "push image successfully!"

  RENDER-TEMPLATE-ACTIONS:
    runs-on: ubuntu-latest
    needs: [Build-Code-Actions]
    steps:
      - uses: actions/checkout@v4
      - name: Render Template
        env:
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          mkdir deploy

          BUILD_TIME=${{ needs.Build-Code-Actions.outputs.build_time }}
          IMAGE_NAME=${IMAGE_REPO_NAME}/${SERVICE_NAME}:$(git rev-parse --short HEAD)_$BUILD_TIME
          echo "Image name: $IMAGE_NAME"

          cp ${{ github.workspace }}/.github/workflows/templates/deployment.tmpl deploy/deployment.yaml
          cp ${{ github.workspace }}/.github/workflows/templates/service.tmpl deploy/service.yaml
          ls -lah deploy

          NAMESPACE=${APP_NAMESPACE}
          BUILD_ENV=${APP_BUILD_ENV}

          sed -i "s/\${SERVICE_NAME}/${SERVICE_NAME}/g" deploy/deployment.yaml
          sed -i "s! \${IMAGE_NAME}! ${IMAGE_NAME}! g" deploy/deployment.yaml
          sed -i "s/\${PORT}/${PROJECT_PORT}/g" deploy/deployment.yaml
          sed -i "s/\${Replicas}/${REPLICAS}/g" deploy/deployment.yaml
          sed -i "s/\${SERVER_ENV}/${BUILD_ENV}/g" deploy/deployment.yaml
          sed -i "s/\${HealthTime}/${HEALTH_TIME}/g" deploy/deployment.yaml
          sed -i "s/\${NAMESPACE}/${NAMESPACE}/g" deploy/deployment.yaml
          sed -i "s/\${MEMORY_LIMITS}/${MEMORY_LIMITS}/g" deploy/deployment.yaml
          sed -i "s/\${MEMORY_REQUESTS}/${MEMORY_REQUESTS}/g" deploy/deployment.yaml
          sed -i "s/\${CPU_LIMITS}/${CPU_LIMITS}/g" deploy/deployment.yaml
          sed -i "s/\${CPU_REQUESTS}/${CPU_REQUESTS}/g" deploy/deployment.yaml
          sed -i "s/\${PORT}/${PROJECT_PORT}/g" deploy/service.yaml
          sed -i "s/\${SERVICE_NAME}/${SERVICE_NAME}/g" deploy/service.yaml
          sed -i "s/\${NAMESPACE}/${NAMESPACE}/g" deploy/service.yaml

      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: deploy_files
          path: deploy

  DEPLOY-APP-ACTIONS:
    runs-on: ubuntu-latest
    needs:
      - Build-Code-Actions
      - RENDER-TEMPLATE-ACTIONS

    steps:
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: deploy_files
          path: /tmp

      - name: Deploy app
        env:
          AWS_API_SERVER: ${{ secrets.AWS_API_SERVER }}
          AWS_API_TOKEN: ${{ secrets.AWS_API_TOKEN }}
        run: |
          mkdir deploy
          cp /tmp/deployment.yaml ./deploy/deployment.yaml
          cp /tmp/service.yaml ./deploy/service.yaml

          echo "downloading kubectl tools"
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

          chmod +x kubectl

          echo -e "deployment file\n"
          cat ./deploy/deployment.yaml
          echo -e "\n"
          echo -e "service file\n"
          cat ./deploy/service.yaml

          NAMESPACE=${APP_NAMESPACE}

          echo -e "\n"
          echo "deploying app"

          ./kubectl --insecure-skip-tls-verify --server=${AWS_API_SERVER} --token=${AWS_API_TOKEN} apply -f deploy/deployment.yaml
          ./kubectl --insecure-skip-tls-verify --server=${AWS_API_SERVER} --token=${AWS_API_TOKEN} apply -f deploy/service.yaml
          echo "app configured"

          for i in $(seq 1 48); do
              pod_status=$(kubectl --insecure-skip-tls-verify --server=${AWS_API_SERVER} --token=${AWS_API_TOKEN} -n ${NAMESPACE} get po | grep ${SERVICE_NAME} | awk '{print $2,$3}' | grep -v '1/1 Running' | wc -l)
              if [ $? != 0 ]; then
                  echo "script execute failed!"
                  exit 1
              fi
              if [ x${pod_status} == x"0" ]; then
                  echo "ÊúçÂä°ÈÉ®ÁΩ≤ÂÆåÊàêÔºåËØ∑Áü•ÊÇâ"
                  exit
              else
                  echo "ÊúçÂä°ÈÉ®ÁΩ≤‰∏≠ÔºåËØ∑Áü•ÊÇâ......"
                  deploy=$(kubectl --insecure-skip-tls-verify --server=${AWS_API_SERVER} --token=${AWS_API_TOKEN} -n ${NAMESPACE} get po | grep ${SERVICE_NAME})
                  echo "ÊúçÂä°ÈÉ®ÁΩ≤Áä∂ÊÄÅ: ${deploy}"
                  sleep 15
              fi
              if [ $i == 48 ]; then
                  echo "ÊúçÂä°ÈÉ®ÁΩ≤ÊïÖÈöúÔºåËØ∑ËÅîÁ≥ªËøêÁª¥"
                  deploy=$(kubectl --insecure-skip-tls-verify --server=${AWS_API_SERVER} --token=${AWS_API_TOKEN} -n ${NAMESPACE} get po | grep ${SERVICE_NAME})
                  error_pod=$(kubectl --insecure-skip-tls-verify --server=${AWS_API_SERVER} --token=${AWS_API_TOKEN} -n ${NAMESPACE} get po | grep ${SERVICE_NAME} | grep -v '1/1' | head -n 1 | awk '{print $1}')
                  error_log=$(kubectl --insecure-skip-tls-verify --server=${AWS_API_SERVER} --token=${AWS_API_TOKEN} -n ${NAMESPACE} logs ${error_pod})
                  echo "ÊúçÂä°ÈÉ®ÁΩ≤Áä∂ÊÄÅ: ${deploy}"
                  echo "ÈîôËØØÊó•Âøó: ${error_log}"
                  exit 1
              fi
          done
